[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS624",
    "section": "",
    "text": "In this webpage, I am going to share with you my learning journey of geospatial analytics.\nReference has been taken from the following webpages/resources:\n\nISSS624 - Applied Geospatial Analytics\nR for Geospatial Data Science and Analytics"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "hands-on_ex1.html",
    "href": "hands-on_ex1.html",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "This exercise covers the following areas:\n\nGeospatial Data Wrangling with R\nChoropleth Mapping with R"
  },
  {
    "objectID": "hands-on_ex1.html#getting-started",
    "href": "hands-on_ex1.html#getting-started",
    "title": "Hands-on Exercise 1",
    "section": "Getting Started",
    "text": "Getting Started\nInstall and load the necessary packages\n\npackages = c('sf', 'tidyverse')\nfor (p in packages){\n  if(!require(p, character.only = T)){\n    install.packages(p)\n  }\n  library(p, character.only = T)\n}\n\nLoading required package: sf\n\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\n\nLoading required package: tidyverse\n\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()"
  },
  {
    "objectID": "hands-on_ex1.html#reading-in-geospatial-data",
    "href": "hands-on_ex1.html#reading-in-geospatial-data",
    "title": "Hands-on Exercise 1",
    "section": "Reading in Geospatial Data",
    "text": "Reading in Geospatial Data\nReading in Master Plan 2014 Subzone Boundary (Web) shp file\n\nmpsz = st_read(dsn = 'data/session1/geospatial',\n               layer = 'MP14_SUBZONE_WEB_PL')\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\Users\\fongb\\Desktop\\MITB\\ISSS624 - Applied Geospatial Analytics\\quarto\\fongbx\\ISSS624\\data\\session1\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nReading in Cycling Path shp file\n\ncyclingpath = st_read(dsn = 'data/session1/geospatial',\n                      layer = 'CyclingPath')\n\nReading layer `CyclingPath' from data source \n  `C:\\Users\\fongb\\Desktop\\MITB\\ISSS624 - Applied Geospatial Analytics\\quarto\\fongbx\\ISSS624\\data\\session1\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1625 features and 2 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 12711.19 ymin: 28711.33 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\nReading in Pre-Schools kml file\n\npreschool = st_read('data/session1/geospatial/pre-schools-location-kml.kml')\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `C:\\Users\\fongb\\Desktop\\MITB\\ISSS624 - Applied Geospatial Analytics\\quarto\\fongbx\\ISSS624\\data\\session1\\geospatial\\pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1359 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84"
  },
  {
    "objectID": "hands-on_ex1.html#checking-contents-of-simple-feature-sf-dataframe",
    "href": "hands-on_ex1.html#checking-contents-of-simple-feature-sf-dataframe",
    "title": "Hands-on Exercise 1",
    "section": "Checking Contents of Simple Feature (sf) Dataframe",
    "text": "Checking Contents of Simple Feature (sf) Dataframe\nUsing st_geometry() to view the geometries\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\nUsing glimpse() from dplyr to view attribute information\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\nView complete information of first few rows with head()\n\nhead(mpsz, n=3)\n\nSimple feature collection with 3 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 28160.23 ymin: 28369.47 xmax: 32362.39 ymax: 30247.18\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO    SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N PLN_AREA_C\n1        1          1 MARINA SOUTH    MSSZ01      Y    MARINA SOUTH         MS\n2        2          1 PEARL'S HILL    OTSZ01      Y          OUTRAM         OT\n3        3          3    BOAT QUAY    SRSZ03      Y SINGAPORE RIVER         SR\n        REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR\n1 CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84 29220.19\n2 CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06 29782.05\n3 CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96 29974.66\n  SHAPE_Leng SHAPE_Area                       geometry\n1   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3   1740.926   160807.5 MULTIPOLYGON (((29932.33 29..."
  },
  {
    "objectID": "hands-on_ex1.html#plotting-geospatial-data",
    "href": "hands-on_ex1.html#plotting-geospatial-data",
    "title": "Hands-on Exercise 1",
    "section": "Plotting Geospatial Data",
    "text": "Plotting Geospatial Data\nUsing plot() to visualise the geospatial features. The default plot of an sf object is a multi-plot of all attributes (columns), up to a reasonable maximum as shown below.\n(Note: plot() is mean for plotting the geospatial object for quick look. For high cartographic quality plot, other R package such as tmap should be used.)\n\nplot(mpsz)\n\nWarning: plotting the first 9 out of 15 attributes; use max.plot = 15 to plot\nall\n\n\n\n\n\nWe can customise our plot by choosing to plot only the geometry, using the code chunk below.\n\nplot(st_geometry(mpsz))\n\n\n\n\nAlternatively, we can also choose to plot the sf object by using a specific attribute as shown in the code chunk below.\n\nplot(mpsz['PLN_AREA_N'])"
  },
  {
    "objectID": "hands-on_ex1.html#working-with-projection",
    "href": "hands-on_ex1.html#working-with-projection",
    "title": "Hands-on Exercise 1",
    "section": "Working with Projection",
    "text": "Working with Projection\nIn order to perform geoprocessing using two geospatial data, we need to ensure that both geospatial data are projected using similar coordinate reference system (crs). When we project a simple feature (sf) dataframe from one crs to another crs, this process is called projection transformation.\nCheck the coordinate reference system of a sd dataframe using st_crs(). In the below sf dataframe, although it is projected in svy21, but when we read till the end of the print, it indicates that the EPSG is 9001. This is a wrong EPSG code because the correct EPSG code for svy21 should be 3414.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nIn order to assign the correct EPSG code to, st_set_crs() of sf package is used as shown in the code chunk below. Note that this does not perform projection transformation, it only changes/corrects the assigned crs for the dataframe.\n\nmpsz3414 <- st_set_crs(mpsz, 3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\nIn geospatial analytics, it is very common for us to transform the original data from geographic coordinate system to projected coordinate system. This is because geographic coordinate system is not appropriate if the analysis need to use distance or/and area measurements.\nFor example, in the preschool sf dataframe, it is in wgs84 crs.\n\nst_crs(preschool)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n\nTo reproject preschool from one crs to another crs mathematically, we need to perform projection transformation using the code chunk below.\n(Note: In practice, we need to find out the appropriate project crs to use before performing projection transformation)\n\npreschool3414 <- st_transform(preschool, crs=3414)\nst_crs(preschool3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]"
  },
  {
    "objectID": "hands-on_ex1.html#importing-and-converting-aspatial-data",
    "href": "hands-on_ex1.html#importing-and-converting-aspatial-data",
    "title": "Hands-on Exercise 1",
    "section": "Importing and Converting Aspatial Data",
    "text": "Importing and Converting Aspatial Data\nIn practice, it is not unusual that we will come across aspatial data. These are not geospatial data but among the data fields, there are two fields that capture the x- and y-coordinates of the data points. We will learn to import an aspatial data into R environment and save it as a tibble data frame. Then, we will convert it into a sf dataframe.\nWe will load in the listings.csv data from AirBnb. As it is in csv format, we will use read_csv() of readr package to import the file. The output R object from read_csv() is a tibble dataframe.\n\nlistings <- read_csv('data/session1/aspatial/listings.csv')\n\nRows: 4252 Columns: 16\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr   (5): name, host_name, neighbourhood_group, neighbourhood, room_type\ndbl  (10): id, host_id, latitude, longitude, price, minimum_nights, number_o...\ndate  (1): last_review\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nUse list() from Base R (instead of glimpse()) to examine the tibble dataframe. Two useful fields we are going to use in the next phase are latitude and longitude. Note that they are in decimal degree format. As a best guess, we will assume that the data is in wgs84 Geographic Coordinate System.\n\nlist(listings)\n\n[[1]]\n# A tibble: 4,252 × 16\n       id name     host_id host_…¹ neigh…² neigh…³ latit…⁴ longi…⁵ room_…⁶ price\n    <dbl> <chr>      <dbl> <chr>   <chr>   <chr>     <dbl>   <dbl> <chr>   <dbl>\n 1  50646 Pleasan…  227796 Sujatha Centra… Bukit …    1.33    104. Privat…    80\n 2  71609 Ensuite…  367042 Belinda East R… Tampin…    1.35    104. Privat…   178\n 3  71896 B&B  Ro…  367042 Belinda East R… Tampin…    1.35    104. Privat…    81\n 4  71903 Room 2-…  367042 Belinda East R… Tampin…    1.35    104. Privat…    81\n 5 275343 Conveni… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    52\n 6 275344 15 mins… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    40\n 7 294281 5 mins … 1521514 Elizab… Centra… Newton     1.31    104. Privat…    72\n 8 301247 Nice ro… 1552002 Rahul   Centra… Geylang    1.32    104. Privat…    41\n 9 324945 20 Mins… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    49\n10 330089 Accomo@… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    49\n# … with 4,242 more rows, 6 more variables: minimum_nights <dbl>,\n#   number_of_reviews <dbl>, last_review <date>, reviews_per_month <dbl>,\n#   calculated_host_listings_count <dbl>, availability_365 <dbl>, and\n#   abbreviated variable names ¹​host_name, ²​neighbourhood_group,\n#   ³​neighbourhood, ⁴​latitude, ⁵​longitude, ⁶​room_type\n\n\nThe code chunk below converts listing dataframe into a sf dataframe by using st_as_sf() of sf packages.\n\ncoords argument requires us to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.\ncrs argument requires us to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. We can search for other country's epsg code by referring to epsg.io.\n\n\nlisting_sf <- st_as_sf(listings,\n                       coords = c('longitude', 'latitude'),\n                       crs=4326) %>% \n  st_transform(crs=3414)\n\nWe can examine the content of the newly created sf dataframe using glimpse(). The table below shows the content of listing_sf. Notice that a new column called geometry has been added into the dataframe. On the other hand, the longitude and latitude columns have been dropped from the data frame.\n\nglimpse(listing_sf)\n\nRows: 4,252\nColumns: 15\n$ id                             <dbl> 50646, 71609, 71896, 71903, 275343, 275…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <dbl> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <dbl> 80, 178, 81, 81, 52, 40, 72, 41, 49, 49…\n$ minimum_nights                 <dbl> 90, 90, 90, 90, 14, 14, 90, 8, 14, 14, …\n$ number_of_reviews              <dbl> 18, 20, 24, 48, 20, 13, 133, 105, 14, 1…\n$ last_review                    <date> 2014-07-08, 2019-12-28, 2014-12-10, 20…\n$ reviews_per_month              <dbl> 0.22, 0.28, 0.33, 0.67, 0.20, 0.16, 1.2…\n$ calculated_host_listings_count <dbl> 1, 4, 4, 4, 50, 50, 7, 1, 50, 50, 50, 4…\n$ availability_365               <dbl> 365, 365, 365, 365, 353, 364, 365, 90, …\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…"
  },
  {
    "objectID": "hands-on_ex1.html#geoprocessing-with-sf-package",
    "href": "hands-on_ex1.html#geoprocessing-with-sf-package",
    "title": "Hands-on Exercise 1",
    "section": "Geoprocessing with sf package",
    "text": "Geoprocessing with sf package\nBesides providing functions to handling (i.e. importing, exporting, assigning projection, transforming projection etc) geospatial data, sf package also offers a wide range of geoprocessing (also known as GIS analysis) functions. Specifically, we will learn how to perform two commonly used geoprocessing functions, namely buffering and point in polygon count.\n\nBuffering\nThe scenario:\nThe authority is planning to upgrade the existing cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extent of the land need to be acquired and their total area.\nThe solution:\nFirstly, st_buffer() of sf package is used to compute the 5-meter buffers around cycling paths.\n\nbuffer_cycling <- st_buffer(cyclingpath,\n                            dist=5,\n                            nQuadSegs=30)\n\nThis is followed by calculating the area of the buffers as shown in the code chunk below.\n\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\nLastly, sum() of Base R will be used to derive the total land involved\n\nsum(buffer_cycling$AREA)\n\n773143.9 [m^2]\n\n\n\n\nPoint-in-polygon count\nThe scenario:\nA pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\nThe solution:\nThe code chunk below performs two operations at one go. Firstly, identify pre-schools located inside each Planning Subzone by using st_intersects(). Next, lengths() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.\n\nmpsz3414$PreSch_Count <- lengths(st_intersects(mpsz3414, preschool3414))\n\nWe can check the summary statistics of the newly derived PreSch Count field by using summary() as shown in the code chunk below.\n\nsummary(mpsz3414$PreSch_Count)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.000   4.207   6.000  37.000 \n\n\nTo list the planning subzone with the most number of pre-school, the top_n() of dplyr package is used as shown in the code chunk below.\n\ntop_n(mpsz3414, 1, PreSch_Count)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 23449.05 ymin: 46001.23 xmax: 25594.22 ymax: 47996.47\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      290          3 WOODLANDS EAST    WDSZ03      N  WOODLANDS         WD\n      REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR\n1 NORTH REGION       NR C90769E43EE6B0F2 2014-12-05 24506.64 46991.63\n  SHAPE_Leng SHAPE_Area                       geometry PreSch_Count\n1   6603.608    2553464 MULTIPOLYGON (((24786.75 46...           37\n\n\nThe solution:\nFirstly, the code chunk below uses st_area() of sf package to derive the area of each planning subzone.\n\nmpsz3414$Area <- mpsz3414 %>%\n  st_area()\n\nNext, mutate() of dplyr package is used to compute the density by using the code chunk below.\n\nmpsz3414 <- mpsz3414 %>% \n  mutate(PreSch_Density = PreSch_Count/Area * 1000000)\n\n\n\nExploratory Data Analysis (EDA)\nWe can plot a histogram to reveal the distribution of PreSch_Density.\n\nggplot(data=mpsz3414,\n       aes(x=as.numeric(PreSch_Density))) +\n  geom_histogram(bins=20,\n                 color='black',\n                 fill='salmon') +\n  labs(title='Are pre-schools evenly distributed in Singapore?',\n       subtitle='There are many planning subzones with a single pre-school.\\nOn the other hand, there are two planning subzones with at least 20 pre-schools.',\n       x='Pre-school Density (per km sq)',\n       y='Frequency')\n\n\n\n\nWe can plot a scatterplot to show the relationship between PreSch_Density and PreSch_Count.\n\nggplot(data=mpsz3414,\n       aes(x=as.numeric(PreSch_Density),\n           y=PreSch_Count)) +\n  geom_point() +\n  labs(title='How are the pre-school counts related to the pre-school density?',\n       x='Pre-school Density (per km sq)',\n       y='Pre-school count')"
  },
  {
    "objectID": "hands-on_ex1.1.html",
    "href": "hands-on_ex1.1.html",
    "title": "Hands-on Exercise 1.1",
    "section": "",
    "text": "This exercise covers the following:\n\nGeospatial Data Wrangling with R"
  },
  {
    "objectID": "hands-on_ex1.1.html#getting-started",
    "href": "hands-on_ex1.1.html#getting-started",
    "title": "Hands-on Exercise 1.1",
    "section": "Getting Started",
    "text": "Getting Started\nInstall and load the necessary packages\n\npackages = c('sf', 'tidyverse')\nfor (p in packages){\n  if(!require(p, character.only = T)){\n    install.packages(p)\n  }\n  library(p, character.only = T)\n}\n\nLoading required package: sf\n\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\n\nLoading required package: tidyverse\n\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()"
  },
  {
    "objectID": "hands-on_ex1.1.html#reading-in-geospatial-data",
    "href": "hands-on_ex1.1.html#reading-in-geospatial-data",
    "title": "Hands-on Exercise 1.1",
    "section": "Reading in Geospatial Data",
    "text": "Reading in Geospatial Data\nReading in Master Plan 2014 Subzone Boundary (Web) shp file\n\nmpsz <- st_read(dsn = 'data/session1/geospatial',\n               layer = 'MP14_SUBZONE_WEB_PL')\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\Users\\fongb\\Desktop\\MITB\\ISSS624 - Applied Geospatial Analytics\\quarto\\fongbx\\ISSS624\\data\\session1\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nReading in Cycling Path shp file\n\ncyclingpath <- st_read(dsn = 'data/session1/geospatial',\n                      layer = 'CyclingPath')\n\nReading layer `CyclingPath' from data source \n  `C:\\Users\\fongb\\Desktop\\MITB\\ISSS624 - Applied Geospatial Analytics\\quarto\\fongbx\\ISSS624\\data\\session1\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1625 features and 2 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 12711.19 ymin: 28711.33 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\nReading in Pre-Schools kml file\n\npreschool <- st_read('data/session1/geospatial/pre-schools-location-kml.kml')\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `C:\\Users\\fongb\\Desktop\\MITB\\ISSS624 - Applied Geospatial Analytics\\quarto\\fongbx\\ISSS624\\data\\session1\\geospatial\\pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1359 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84"
  },
  {
    "objectID": "hands-on_ex1.1.html#checking-contents-of-simple-feature-sf-dataframe",
    "href": "hands-on_ex1.1.html#checking-contents-of-simple-feature-sf-dataframe",
    "title": "Hands-on Exercise 1.1",
    "section": "Checking Contents of Simple Feature (sf) Dataframe",
    "text": "Checking Contents of Simple Feature (sf) Dataframe\nUsing st_geometry() to view the geometries\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\nUsing glimpse() from dplyr to view attribute information\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\nView complete information of first few rows with head()\n\nhead(mpsz, n=3)\n\nSimple feature collection with 3 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 28160.23 ymin: 28369.47 xmax: 32362.39 ymax: 30247.18\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO    SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N PLN_AREA_C\n1        1          1 MARINA SOUTH    MSSZ01      Y    MARINA SOUTH         MS\n2        2          1 PEARL'S HILL    OTSZ01      Y          OUTRAM         OT\n3        3          3    BOAT QUAY    SRSZ03      Y SINGAPORE RIVER         SR\n        REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR\n1 CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84 29220.19\n2 CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06 29782.05\n3 CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96 29974.66\n  SHAPE_Leng SHAPE_Area                       geometry\n1   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3   1740.926   160807.5 MULTIPOLYGON (((29932.33 29..."
  },
  {
    "objectID": "hands-on_ex1.1.html#plotting-geospatial-data",
    "href": "hands-on_ex1.1.html#plotting-geospatial-data",
    "title": "Hands-on Exercise 1.1",
    "section": "Plotting Geospatial Data",
    "text": "Plotting Geospatial Data\nUsing plot() to visualise the geospatial features. The default plot of an sf object is a multi-plot of all attributes (columns), up to a reasonable maximum as shown below.\n(Note: plot() is mean for plotting the geospatial object for quick look. For high cartographic quality plot, other R package such as tmap should be used.)\n\nplot(mpsz)\n\nWarning: plotting the first 9 out of 15 attributes; use max.plot = 15 to plot\nall\n\n\n\n\n\nWe can customise our plot by choosing to plot only the geometry, using the code chunk below.\n\nplot(st_geometry(mpsz))\n\n\n\n\nAlternatively, we can also choose to plot the sf object by using a specific attribute as shown in the code chunk below.\n\nplot(mpsz['PLN_AREA_N'])"
  },
  {
    "objectID": "hands-on_ex1.1.html#working-with-projection",
    "href": "hands-on_ex1.1.html#working-with-projection",
    "title": "Hands-on Exercise 1.1",
    "section": "Working with Projection",
    "text": "Working with Projection\nIn order to perform geoprocessing using two geospatial data, we need to ensure that both geospatial data are projected using similar coordinate reference system (crs). When we project a simple feature (sf) dataframe from one crs to another crs, this process is called projection transformation.\nCheck the coordinate reference system of a sd dataframe using st_crs(). In the below sf dataframe, although it is projected in svy21, but when we read till the end of the print, it indicates that the EPSG is 9001. This is a wrong EPSG code because the correct EPSG code for svy21 should be 3414.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nIn order to assign the correct EPSG code to, st_set_crs() of sf package is used as shown in the code chunk below. Note that this does not perform projection transformation, it only changes/corrects the assigned crs for the dataframe.\n\nmpsz3414 <- st_set_crs(mpsz, 3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\nIn geospatial analytics, it is very common for us to transform the original data from geographic coordinate system to projected coordinate system. This is because geographic coordinate system is not appropriate if the analysis need to use distance or/and area measurements.\nFor example, in the preschool sf dataframe, it is in wgs84 crs.\n\nst_crs(preschool)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n\nTo reproject preschool from one crs to another crs mathematically, we need to perform projection transformation using the code chunk below.\n(Note: In practice, we need to find out the appropriate project crs to use before performing projection transformation)\n\npreschool3414 <- st_transform(preschool, crs=3414)\nst_crs(preschool3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]"
  },
  {
    "objectID": "hands-on_ex1.1.html#importing-and-converting-aspatial-data",
    "href": "hands-on_ex1.1.html#importing-and-converting-aspatial-data",
    "title": "Hands-on Exercise 1.1",
    "section": "Importing and Converting Aspatial Data",
    "text": "Importing and Converting Aspatial Data\nIn practice, it is not unusual that we will come across aspatial data. These are not geospatial data but among the data fields, there are two fields that capture the x- and y-coordinates of the data points. We will learn to import an aspatial data into R environment and save it as a tibble data frame. Then, we will convert it into a sf dataframe.\nWe will load in the listings.csv data from AirBnb. As it is in csv format, we will use read_csv() of readr package to import the file. The output R object from read_csv() is a tibble dataframe.\n\nlistings <- read_csv('data/session1/aspatial/listings.csv')\n\nRows: 4252 Columns: 16\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr   (5): name, host_name, neighbourhood_group, neighbourhood, room_type\ndbl  (10): id, host_id, latitude, longitude, price, minimum_nights, number_o...\ndate  (1): last_review\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nUse list() from Base R (instead of glimpse()) to examine the tibble dataframe. Two useful fields we are going to use in the next phase are latitude and longitude. Note that they are in decimal degree format. As a best guess, we will assume that the data is in wgs84 Geographic Coordinate System.\n\nlist(listings)\n\n[[1]]\n# A tibble: 4,252 × 16\n       id name     host_id host_…¹ neigh…² neigh…³ latit…⁴ longi…⁵ room_…⁶ price\n    <dbl> <chr>      <dbl> <chr>   <chr>   <chr>     <dbl>   <dbl> <chr>   <dbl>\n 1  50646 Pleasan…  227796 Sujatha Centra… Bukit …    1.33    104. Privat…    80\n 2  71609 Ensuite…  367042 Belinda East R… Tampin…    1.35    104. Privat…   178\n 3  71896 B&B  Ro…  367042 Belinda East R… Tampin…    1.35    104. Privat…    81\n 4  71903 Room 2-…  367042 Belinda East R… Tampin…    1.35    104. Privat…    81\n 5 275343 Conveni… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    52\n 6 275344 15 mins… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    40\n 7 294281 5 mins … 1521514 Elizab… Centra… Newton     1.31    104. Privat…    72\n 8 301247 Nice ro… 1552002 Rahul   Centra… Geylang    1.32    104. Privat…    41\n 9 324945 20 Mins… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    49\n10 330089 Accomo@… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    49\n# … with 4,242 more rows, 6 more variables: minimum_nights <dbl>,\n#   number_of_reviews <dbl>, last_review <date>, reviews_per_month <dbl>,\n#   calculated_host_listings_count <dbl>, availability_365 <dbl>, and\n#   abbreviated variable names ¹​host_name, ²​neighbourhood_group,\n#   ³​neighbourhood, ⁴​latitude, ⁵​longitude, ⁶​room_type\n\n\nThe code chunk below converts listing dataframe into a sf dataframe by using st_as_sf() of sf packages.\n\ncoords argument requires us to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.\ncrs argument requires us to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. We can search for other country’s epsg code by referring to epsg.io.\n\n\nlisting_sf <- st_as_sf(listings,\n                       coords = c('longitude', 'latitude'),\n                       crs=4326) %>% \n  st_transform(crs=3414)\n\nWe can examine the content of the newly created sf dataframe using glimpse(). The table below shows the content of listing_sf. Notice that a new column called geometry has been added into the dataframe. On the other hand, the longitude and latitude columns have been dropped from the data frame.\n\nglimpse(listing_sf)\n\nRows: 4,252\nColumns: 15\n$ id                             <dbl> 50646, 71609, 71896, 71903, 275343, 275…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <dbl> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <dbl> 80, 178, 81, 81, 52, 40, 72, 41, 49, 49…\n$ minimum_nights                 <dbl> 90, 90, 90, 90, 14, 14, 90, 8, 14, 14, …\n$ number_of_reviews              <dbl> 18, 20, 24, 48, 20, 13, 133, 105, 14, 1…\n$ last_review                    <date> 2014-07-08, 2019-12-28, 2014-12-10, 20…\n$ reviews_per_month              <dbl> 0.22, 0.28, 0.33, 0.67, 0.20, 0.16, 1.2…\n$ calculated_host_listings_count <dbl> 1, 4, 4, 4, 50, 50, 7, 1, 50, 50, 50, 4…\n$ availability_365               <dbl> 365, 365, 365, 365, 353, 364, 365, 90, …\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…"
  },
  {
    "objectID": "hands-on_ex1.1.html#geoprocessing-with-sf-package",
    "href": "hands-on_ex1.1.html#geoprocessing-with-sf-package",
    "title": "Hands-on Exercise 1.1",
    "section": "Geoprocessing with sf package",
    "text": "Geoprocessing with sf package\nBesides providing functions to handling (i.e. importing, exporting, assigning projection, transforming projection etc) geospatial data, sf package also offers a wide range of geoprocessing (also known as GIS analysis) functions. Specifically, we will learn how to perform two commonly used geoprocessing functions, namely buffering and point in polygon count.\n\nBuffering\nThe scenario:\nThe authority is planning to upgrade the existing cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extent of the land need to be acquired and their total area.\nThe solution:\nFirstly, st_buffer() of sf package is used to compute the 5-meter buffers around cycling paths.\n\nbuffer_cycling <- st_buffer(cyclingpath,\n                            dist=5,\n                            nQuadSegs=30)\n\nThis is followed by calculating the area of the buffers as shown in the code chunk below.\n\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\nLastly, sum() of Base R will be used to derive the total land involved\n\nsum(buffer_cycling$AREA)\n\n773143.9 [m^2]\n\n\n\n\nPoint-in-polygon count\nThe scenario:\nA pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\nThe solution:\nThe code chunk below performs two operations at one go. Firstly, identify pre-schools located inside each Planning Subzone by using st_intersects(). Next, lengths() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.\n\nmpsz3414$PreSch_Count <- lengths(st_intersects(mpsz3414, preschool3414))\n\nWe can check the summary statistics of the newly derived PreSch Count field by using summary() as shown in the code chunk below.\n\nsummary(mpsz3414$PreSch_Count)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.000   4.207   6.000  37.000 \n\n\nTo list the planning subzone with the most number of pre-school, the top_n() of dplyr package is used as shown in the code chunk below.\n\ntop_n(mpsz3414, 1, PreSch_Count)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 23449.05 ymin: 46001.23 xmax: 25594.22 ymax: 47996.47\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      290          3 WOODLANDS EAST    WDSZ03      N  WOODLANDS         WD\n      REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR\n1 NORTH REGION       NR C90769E43EE6B0F2 2014-12-05 24506.64 46991.63\n  SHAPE_Leng SHAPE_Area                       geometry PreSch_Count\n1   6603.608    2553464 MULTIPOLYGON (((24786.75 46...           37\n\n\nThe solution:\nFirstly, the code chunk below uses st_area() of sf package to derive the area of each planning subzone.\n\nmpsz3414$Area <- mpsz3414 %>%\n  st_area()\n\nNext, mutate() of dplyr package is used to compute the density by using the code chunk below.\n\nmpsz3414 <- mpsz3414 %>% \n  mutate(PreSch_Density = PreSch_Count/Area * 1000000)\n\n\n\nExploratory Data Analysis (EDA)\nWe can plot a histogram to reveal the distribution of PreSch_Density.\n\nggplot(data=mpsz3414,\n       aes(x=as.numeric(PreSch_Density))) +\n  geom_histogram(bins=20,\n                 color='black',\n                 fill='salmon') +\n  labs(title='Are pre-schools evenly distributed in Singapore?',\n       subtitle='There are many planning subzones with a single pre-school.\\nOn the other hand, there are two planning subzones with at least 20 pre-schools.',\n       x='Pre-school Density (per km sq)',\n       y='Frequency')\n\n\n\n\nWe can plot a scatterplot to show the relationship between PreSch_Density and PreSch_Count.\n\nggplot(data=mpsz3414,\n       aes(x=as.numeric(PreSch_Density),\n           y=PreSch_Count)) +\n  geom_point() +\n  labs(title='How are the pre-school counts related to the pre-school density?',\n       x='Pre-school Density (per km sq)',\n       y='Pre-school count')"
  },
  {
    "objectID": "hands-on_ex1.2.html",
    "href": "hands-on_ex1.2.html",
    "title": "Hands-on Exercise 1.2",
    "section": "",
    "text": "This exercise covers the following:\n\nChoropleth Mapping with R"
  },
  {
    "objectID": "hands-on_ex1.2.html#getting-started",
    "href": "hands-on_ex1.2.html#getting-started",
    "title": "Hands-on Exercise 1.2",
    "section": "Getting Started",
    "text": "Getting Started\nInstall and load the necessary packages\n\npacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "hands-on_ex1.2.html#reading-in-geospatial-data",
    "href": "hands-on_ex1.2.html#reading-in-geospatial-data",
    "title": "Hands-on Exercise 1.2",
    "section": "Reading in Geospatial Data",
    "text": "Reading in Geospatial Data\nReading in MP14_SUBZONE_WEB_PL shapefile.\n\nmpsz <- st_read(dsn = 'data/session1/geospatial',\n                layer = 'MP14_SUBZONE_WEB_PL')\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\Users\\fongb\\Desktop\\MITB\\ISSS624 - Applied Geospatial Analytics\\quarto\\fongbx\\ISSS624\\data\\session1\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nExamine content of mpsz using the code chunk below\n\nmpsz\n\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29..."
  },
  {
    "objectID": "hands-on_ex1.2.html#reading-in-attribute-data",
    "href": "hands-on_ex1.2.html#reading-in-attribute-data",
    "title": "Hands-on Exercise 1.2",
    "section": "Reading in Attribute Data",
    "text": "Reading in Attribute Data\nReading in Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020 in csv format. This is an aspatial data fie. Although it does not contain any coordinates values, but it’s PA and SZ fields can be used as unique identifiers to geocode to MP14_SUBZONE_WEB_PL shapefile.\n\npopdata <- read_csv('data/session1/aspatial/respopagesextod2011to2020.csv')\n\nRows: 984656 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): PA, SZ, AG, Sex, TOD\ndbl (2): Pop, Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "hands-on_ex1.2.html#data-preparation",
    "href": "hands-on_ex1.2.html#data-preparation",
    "title": "Hands-on Exercise 1.2",
    "section": "Data Preparation",
    "text": "Data Preparation\nExamine popdata\n\nhead(popdata, n=3)\n\n# A tibble: 3 × 7\n  PA         SZ                     AG     Sex   TOD                   Pop  Time\n  <chr>      <chr>                  <chr>  <chr> <chr>               <dbl> <dbl>\n1 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 1- and 2-Room …     0  2011\n2 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 3-Room Flats       10  2011\n3 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 4-Room Flats       30  2011\n\n\nWrangling popdata to capture the population by the different age groups\n\npivot_wider() “widens” data, increasing the number of columns and decreasing the number of rows\n\n\npopdata2020 <- popdata %>% \n  filter(Time == 2020) %>% \n  group_by(PA, SZ, AG) %>% \n  summarise(POP = sum(Pop)) %>% \n  ungroup() %>% \n  pivot_wider(names_from = AG,\n              values_from = POP)\n\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n\npopdata2020\n\n# A tibble: 332 × 21\n   PA      SZ    0_to_…¹ 10_to…² 15_to…³ 20_to…⁴ 25_to…⁵ 30_to…⁶ 35_to…⁷ 40_to…⁸\n   <chr>   <chr>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1 Ang Mo… Ang …     170     280     340     270     260     310     330     400\n 2 Ang Mo… Chen…    1060    1040    1160    1330    1720    2020    2150    2080\n 3 Ang Mo… Chon…     850    1020    1070    1310    1610    1890    1720    1810\n 4 Ang Mo… Kebu…     680     960    1010    1170    1410    1420    1440    1630\n 5 Ang Mo… Semb…     210     400     450     500     500     340     300     370\n 6 Ang Mo… Shan…     560     640     700     860     970    1030     980    1010\n 7 Ang Mo… Tago…     200     390     460     590     680     500     330     430\n 8 Ang Mo… Town…     670     930     830     890    1310    1410    1420    1640\n 9 Ang Mo… Yio …       0       0       0       0       0       0       0       0\n10 Ang Mo… Yio …     160     210     260     300     320     240     250     260\n# … with 322 more rows, 11 more variables: `45_to_49` <dbl>, `5_to_9` <dbl>,\n#   `50_to_54` <dbl>, `55_to_59` <dbl>, `60_to_64` <dbl>, `65_to_69` <dbl>,\n#   `70_to_74` <dbl>, `75_to_79` <dbl>, `80_to_84` <dbl>, `85_to_89` <dbl>,\n#   `90_and_over` <dbl>, and abbreviated variable names ¹​`0_to_4`, ²​`10_to_14`,\n#   ³​`15_to_19`, ⁴​`20_to_24`, ⁵​`25_to_29`, ⁶​`30_to_34`, ⁷​`35_to_39`,\n#   ⁸​`40_to_44`\n\n\nFurther transformation of data, creating new column based on the following:\n\nYOUNG: age group 0 to 4 until age group 20 to 24,\nECONOMY ACTIVE: age group 25-29 until age group 60-64,\nAGED: age group 65 and above,\nTOTAL: all age group, and\nDEPENDENCY: the ratio between young and aged against economy active group\n\n\npopdata2020 <- popdata2020 %>% \n  mutate(YOUNG = rowSums(.[3:6]) + rowSums(.[12])) %>% \n  mutate(ECONOMY_ACTIVE = rowSums(.[7:11]) + rowSums(.[13:15])) %>% \n  mutate(AGED = rowSums(.[16:21])) %>% \n  mutate(TOTAL = rowSums(.[3:21])) %>% \n  mutate(DEPENDENCY = (YOUNG + AGED)/ECONOMY_ACTIVE) %>% \n  select(PA, SZ, YOUNG, ECONOMY_ACTIVE, AGED, TOTAL, DEPENDENCY)\npopdata2020\n\n# A tibble: 332 × 7\n   PA         SZ                     YOUNG ECONOMY_ACTIVE  AGED TOTAL DEPENDENCY\n   <chr>      <chr>                  <dbl>          <dbl> <dbl> <dbl>      <dbl>\n 1 Ang Mo Kio Ang Mo Kio Town Centre  1290           2760   760  4810      0.743\n 2 Ang Mo Kio Cheng San               5640          16460  6050 28150      0.710\n 3 Ang Mo Kio Chong Boon              5100          15000  6470 26570      0.771\n 4 Ang Mo Kio Kebun Bahru             4620          13010  5120 22750      0.749\n 5 Ang Mo Kio Sembawang Hills         1880           3630  1310  6820      0.879\n 6 Ang Mo Kio Shangri-La              3330           9050  3610 15990      0.767\n 7 Ang Mo Kio Tagore                  1940           4480  1530  7950      0.775\n 8 Ang Mo Kio Townsville              4190          11950  5100 21240      0.777\n 9 Ang Mo Kio Yio Chu Kang               0              0     0     0    NaN    \n10 Ang Mo Kio Yio Chu Kang East       1110           2410   750  4270      0.772\n# … with 322 more rows\n\n\nBefore we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other hand the SUBZONE_N and PLN_AREA_N are in uppercase.\n\nmutate_at makes it easier to mutate multiple columns. .funs behaves like a lambda\n\n\npopdata2020 <- popdata2020 %>% \n  mutate_at(.vars = vars(PA, SZ),\n            .funs = funs(toupper)) %>% \n  filter(ECONOMY_ACTIVE > 0)\n\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nℹ Please use a list of either functions or lambdas:\n\n# Simple named list: list(mean = mean, median = median)\n\n# Auto named with `tibble::lst()`: tibble::lst(mean, median)\n\n# Using lambdas list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\n\npopdata2020\n\n# A tibble: 234 × 7\n   PA         SZ                     YOUNG ECONOMY_ACTIVE  AGED TOTAL DEPENDENCY\n   <chr>      <chr>                  <dbl>          <dbl> <dbl> <dbl>      <dbl>\n 1 ANG MO KIO ANG MO KIO TOWN CENTRE  1290           2760   760  4810      0.743\n 2 ANG MO KIO CHENG SAN               5640          16460  6050 28150      0.710\n 3 ANG MO KIO CHONG BOON              5100          15000  6470 26570      0.771\n 4 ANG MO KIO KEBUN BAHRU             4620          13010  5120 22750      0.749\n 5 ANG MO KIO SEMBAWANG HILLS         1880           3630  1310  6820      0.879\n 6 ANG MO KIO SHANGRI-LA              3330           9050  3610 15990      0.767\n 7 ANG MO KIO TAGORE                  1940           4480  1530  7950      0.775\n 8 ANG MO KIO TOWNSVILLE              4190          11950  5100 21240      0.777\n 9 ANG MO KIO YIO CHU KANG EAST       1110           2410   750  4270      0.772\n10 ANG MO KIO YIO CHU KANG WEST       5690          13750  4680 24120      0.754\n# … with 224 more rows\n\n\nNext, left_join() of dplyr is used to join the geographical data and attribute table using planning subzone name e.g. SUBZONE_N and SZ as the common identifier. The mpsz dataset is used as the left data table to ensure that the output will be a sf dataframe.\n\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c('SUBZONE_N' = 'SZ'))\nmpsz_pop2020\n\nSimple feature collection with 323 features and 21 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area              PA YOUNG ECONOMY_ACTIVE AGED\n1  29220.19   5267.381  1630379.3            <NA>    NA             NA   NA\n2  29782.05   3506.107   559816.2          OUTRAM   930           3130 2120\n3  29974.66   1740.926   160807.5 SINGAPORE RIVER     0             40   10\n4  29933.77   3313.625   595428.9     BUKIT MERAH  2600           7450 3320\n5  30005.70   2825.594   387429.4     BUKIT MERAH  2760           6160 1740\n6  29991.38   4428.913  1030378.8     BUKIT MERAH  2800           7340 3420\n7  30230.86   3275.312   551732.0     BUKIT MERAH  2750           8080 3610\n8  30222.86   2208.619   290184.7 SINGAPORE RIVER     0             50   10\n9  29893.78   6571.323  1084792.3      QUEENSTOWN  1120           2770  610\n10 30104.18   3454.239   631644.3      QUEENSTOWN    30            160   60\n   TOTAL DEPENDENCY                       geometry\n1     NA         NA MULTIPOLYGON (((31495.56 30...\n2   6180  0.9744409 MULTIPOLYGON (((29092.28 30...\n3     50  0.2500000 MULTIPOLYGON (((29932.33 29...\n4  13370  0.7946309 MULTIPOLYGON (((27131.28 30...\n5  10660  0.7305195 MULTIPOLYGON (((26451.03 30...\n6  13560  0.8474114 MULTIPOLYGON (((25899.7 297...\n7  14440  0.7871287 MULTIPOLYGON (((27746.95 30...\n8     60  0.2000000 MULTIPOLYGON (((29351.26 29...\n9   4500  0.6245487 MULTIPOLYGON (((20996.49 30...\n10   250  0.5625000 MULTIPOLYGON (((24472.11 29...\n\n\nWrite to an rds file\n\nwrite_rds(mpsz_pop2020, 'data/session1/rds/mpszpop2020_new.rds')"
  },
  {
    "objectID": "hands-on_ex1.2.html#choropleth-mapping-geospatial-data-using-tmap",
    "href": "hands-on_ex1.2.html#choropleth-mapping-geospatial-data-using-tmap",
    "title": "Hands-on Exercise 1.2",
    "section": "Choropleth Mapping Geospatial Data using tmap",
    "text": "Choropleth Mapping Geospatial Data using tmap\nTwo approaches can be used to prepare thematic map using tmap, they are:\n\nPlotting a thematic map quickly by using qtm().\nPlotting highly customisable thematic map by using tmap elements.\n\n\nPlotting a choropleth map quickly by using qtm()\nThe easiest and quickest to draw a choropleth map using tmap is using qtm(). It is concise and provides a good default visualisation in many cases. The code chunk below will draw a cartographic standard choropleth map.\n\ntmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.\nfill argument is used to map the attribute (i.e. DEPENDENCY)\n\n\ntmap_mode('plot')\n\ntmap mode set to plotting\n\nqtm(mpsz_pop2020,\n    fill = 'DEPENDENCY')\n\n\n\n\n\n\nCreating a choropleth map by using tmap’s elements\nDespite its usefulness of drawing a choropleth map quickly and easily, the disadvantge of qtm() is that it makes aesthetics of individual layers harder to control. To draw a high quality cartographic choropleth map as shown in the figure below, tmap’s drawing elements should be used.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = 'Blues',\n          title = 'Dependency ratio') +\n  tm_layout(main.title = 'Distribution of Dependency Ratio by planning subzone',\n            main.title.position = 'center',\n            main.title.size = 1,\n            legend.height = 0.25,\n            legend.width = 0.2,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type = '8star', size = 0.6) +\n  tm_scale_bar() +\n  tm_grid(alpha = 0.2) +\n  tm_credits('Source: Planning Sub-zone boundary from Urban Redevelopment Authority (URA) and Population data from Department of Statistics DOS',\n             position = c('left', 'bottom'))\n\n\n\n\nThe following are step-by-step breakdown of tmap functions:\n\nDrawing a base map\nThe basic building block of tmap is tm_shape() followed by one or more layer elemments such as tm_fill() and tm_polygons(). In the code chunk below, tm_shape() is used to define the input data (i.e mpsz_pop2020) and tm_polygons() is used to draw the planning subzone polygons.\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n\n\n\n\n\n\nDrawing a choropleth map using tm_polygons()\nTo draw a choropleth map showing the geographical distribution of a selected variable by planning subzone, we just need to assign the target variable such as Dependency to tm_polygons().\n\ntm_shape(mpsz_pop2020) + \n  tm_polygons('DEPENDENCY')\n\n\n\n\n\n\nDrawing a choropleth map using tm_polygons()\nActually, tm_polygons() is a wrapper of tm_fill() and tm_border(). tm_fill() shades the polygons by using the default colour scheme and tm_borders() adds the borders of the shapefile onto the choropleth map. The code chunk below draws a choropleth map by using tm_fill() alone.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY')\n\n\n\n\nTo add the boundary of the planning subzones, tm_borders will be used.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY') +\n  tm_borders(lwd = 0.1, alpha = 1)\n\n\n\n\n\n\nData classification methods of tmap\nMost choropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes. tmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks. To define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.\nThe code chunk below shows a quantile data classification that used 5 classes.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          n = 5,\n          style = 'quantile') +\n  tm_borders(alpha = 0.5)\n\n\n\n\nThe below code chunk uses equal data classification method.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          n = 7,\n          style = 'equal') +\n  tm_borders(alpha = 0.5)\n\n\n\n\nThe below code chunk uses kmeans data classification method.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          n = 5,\n          style = 'kmeans') +\n  tm_borders(alpha=0.5)\n\n\n\n\n\n\nPlotting choropleth map with custom break\nFor all built-in classfication styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the tm_fill(). It is important to note that, in tmap the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order).\nBefore we get started, it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics of DEPENDENCY field.\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6519  0.7025  0.7742  0.7645 19.0000      92 \n\n\nUsing the results above, we set break points at 0.60, 0.70, 0.80, and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 19.00. Our breaks vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 19.00).\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          breaks = c(0,0.60,0.70,0.80,0.90,19.00)) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\nColour Scheme\ntmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package. To change the colour, we assign the preferred colour to palette argument of tm_fill() as shown in the code chunk below.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          n = 6,\n          style = 'quantile',\n          palette = 'Blues') +\n  tm_borders(alpha = 0.5)\n\n\n\n\nTo revers the colour shading, add a ‘-’ prefix.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = '-Blues') +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\nMap Layouts\nMap layout refers to the combination of all map elements into a cohensive map. Map elements include among others the objects to be mapped, the title, the scale bar, the compass, margins and aspects ratios. Colour settings and data classification methods covered in the previous section relate to the palette and break-points are used to affect how the map looks.\nMap Legend - In tmap, several legend options are provided to change the placement, format and appearance of the legend.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style = 'jenks',\n          palette = 'Blues',\n          legend.hist = TRUE,\n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = 'Distribution of Dependency Ratio by planning subzone',\n            main.title.position = 'center',\n            main.title.size = 1,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c('right','bottom'),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\nMap Style - tmap allows a wide variety of layout settings to be changed. They can be called by using tmap_style().\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = 'Greens') +\n  tm_borders(alpha = 0.5) +\n  tmap_style('classic')\n\ntmap style set to \"classic\"\n\n\nother available styles are: \"white\", \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"watercolor\" \n\n\n\n\n\nCartographic Furniture - Beside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines. In the code chunk below, tm_compass(), tm_scale_bar() and tm_grid() are used to add compass, scale bar and grid lines onto the choropleth map.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = 'Blues',\n          title = 'No. of persons') +\n  tm_layout(main.title = 'Distribution of Dependency Ratio by planning subzone',\n            main.title.position = 'center',\n            main.title.size = 1,\n            legend.height = 0.25,\n            legend.width = 0.2,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type = '8star', size = 0.6) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits('Source: Planning Sub-zone boundary from Urban Redevelopment Authority (URA) and Population data from Department of Statistics DOS',\n             position = c('left', 'bottom')) +\n  tmap_style('cobalt')\n\ntmap style set to \"cobalt\"\n\n\nother available styles are: \"white\", \"gray\", \"natural\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\n\n\nDrawing small multiple choropleth maps\nIn tmap, small multiple maps can be plotted in three ways:\n\nby assigning multiple values to at least one of the asthetic arguments,\nby defining a group-by variable in tm_facets(), and\nby creating multiple stand-alone maps with tmap_arrange().\n\nAssigning multiple values to at least one of the aesthetics arguments\nIn this example, small multiple choropleth maps are created by defining ncols in tm_fill().\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(c('YOUNG', 'AGED'),\n          style = 'equal',\n          palette = 'Blues') +\n  tm_layout(legend.position = c('right', 'bottom')) +\n  tm_borders(alpha = 0.5) +\n  tmap_style('white')\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\nIn this example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments.\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n\n\n\n\nDefining a group_by variable in tm_facets()\nIn this example, multiple small choropleth maps are created by using tm_facets().\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = 'Blues',\n          thres.poly = 0) +\n  tm_facets(by = 'REGION_N',\n            free.coords = TRUE,\n            drop.shapes = TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c('center', 'center'),\n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\nWarning: The argument drop.shapes has been renamed to drop.units, and is\ntherefore deprecated\n\n\n\n\n\nCreating multiple stand-alone maps with tmap_arrange()\nIn this example, multiple small choropleth maps are created by creating multiple stand-alone maps with tmap_arrange().\n\nyoungmap <- tm_shape(mpsz_pop2020) +\n  tm_polygons('YOUNG',\n              style = 'quantile',\n              palette = 'Blues')\n\nagedmap <- tm_shape(mpsz_pop2020) +\n  tm_polygons('AGED',\n              style = 'quantile',\n              palette = 'Blues')\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n\n\n\n\n\n\nMapping Spatial Object Meeting a Selection Criteria\nInstead of creating small multiple choropleth map, you can also use selection function to map spatial objects meeting the selection criterion.\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N=='CENTRAL REGION', ]) +\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nWarning in pre_process_gt(x, interactive = interactive, orig_crs =\ngm$shape.orig_crs): legend.width controls the width of the legend within a map.\nPlease use legend.outside.size to control the width of the outside legend"
  },
  {
    "objectID": "in-class_exercises/in-class_ex1/in-class_ex1.html",
    "href": "in-class_exercises/in-class_ex1/in-class_ex1.html",
    "title": "In-class Exercise 1",
    "section": "",
    "text": "This exercise covers the following:\n\nSpatial Weights and Applications"
  },
  {
    "objectID": "in-class_exercises/in-class_ex1/in-class_ex1.html#getting-started",
    "href": "in-class_exercises/in-class_ex1/in-class_ex1.html#getting-started",
    "title": "In-class Exercise 1",
    "section": "Getting Started",
    "text": "Getting Started\nInstall and load the required packages. spdep package is a collection of functions for creating spatial weights matrix objects.\n\n# remotes::install_version('spData', version = '2.2.1')\n# install.packages('spdep')\npacman::p_load(sf, spdep, tidyverse, tmap)"
  },
  {
    "objectID": "in-class_exercises/in-class_ex1/in-class_ex1.html#importing-geospatial-data",
    "href": "in-class_exercises/in-class_ex1/in-class_ex1.html#importing-geospatial-data",
    "title": "In-class Exercise 1",
    "section": "Importing Geospatial Data",
    "text": "Importing Geospatial Data\nThis code chunk will import ESRI shapefile into R.\n\n# hunan <- st_read(dsn = 'data/geospatial',\n#                 layer = 'Hunan')"
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html",
    "title": "Hands-on Exercise 1.1",
    "section": "",
    "text": "This exercise covers the following:\n\nGeospatial Data Wrangling with R"
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#getting-started",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#getting-started",
    "title": "Hands-on Exercise 1.1",
    "section": "Getting Started",
    "text": "Getting Started\nInstall and load the necessary packages\n\npackages = c('sf', 'tidyverse')\nfor (p in packages){\n  if(!require(p, character.only = T)){\n    install.packages(p)\n  }\n  library(p, character.only = T)\n}\n\nLoading required package: sf\n\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\n\nLoading required package: tidyverse\n\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()"
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#reading-in-geospatial-data",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#reading-in-geospatial-data",
    "title": "Hands-on Exercise 1.1",
    "section": "Reading in Geospatial Data",
    "text": "Reading in Geospatial Data\nReading in Master Plan 2014 Subzone Boundary (Web) shapefile.\n\nmpsz <- st_read(dsn = 'data/geospatial',\n               layer = 'MP14_SUBZONE_WEB_PL')\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\Users\\fongb\\Desktop\\MITB\\ISSS624 - Applied Geospatial Analytics\\quarto\\fongbx\\ISSS624\\hands-on_exercises\\hands-on_ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nReading in Cycling Path shapefile.\n\ncyclingpath <- st_read(dsn = 'data/geospatial',\n                      layer = 'CyclingPath')\n\nReading layer `CyclingPath' from data source \n  `C:\\Users\\fongb\\Desktop\\MITB\\ISSS624 - Applied Geospatial Analytics\\quarto\\fongbx\\ISSS624\\hands-on_exercises\\hands-on_ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1625 features and 2 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 12711.19 ymin: 28711.33 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\nReading in Pre-Schools kml file. We will use the full path to load for kml and geojson files. This is unlike the shapefiles previously where we first provide the data source name (dsn) then the layers. This is because for shapefiles there are many multiple subfiles/layers.\n\npreschool <- st_read('data/geospatial/pre-schools-location-kml.kml')\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `C:\\Users\\fongb\\Desktop\\MITB\\ISSS624 - Applied Geospatial Analytics\\quarto\\fongbx\\ISSS624\\hands-on_exercises\\hands-on_ex1\\data\\geospatial\\pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1359 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84"
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#checking-contents-of-simple-feature-sf-dataframe",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#checking-contents-of-simple-feature-sf-dataframe",
    "title": "Hands-on Exercise 1.1",
    "section": "Checking Contents of Simple Feature (sf) Dataframe",
    "text": "Checking Contents of Simple Feature (sf) Dataframe\nUsing st_geometry() to view the geometries\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\nUsing glimpse() from dplyr to view attribute information\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\nView complete information of first few rows with head()\n\nhead(mpsz, n=3)\n\nSimple feature collection with 3 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 28160.23 ymin: 28369.47 xmax: 32362.39 ymax: 30247.18\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO    SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N PLN_AREA_C\n1        1          1 MARINA SOUTH    MSSZ01      Y    MARINA SOUTH         MS\n2        2          1 PEARL'S HILL    OTSZ01      Y          OUTRAM         OT\n3        3          3    BOAT QUAY    SRSZ03      Y SINGAPORE RIVER         SR\n        REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR\n1 CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84 29220.19\n2 CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06 29782.05\n3 CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96 29974.66\n  SHAPE_Leng SHAPE_Area                       geometry\n1   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3   1740.926   160807.5 MULTIPOLYGON (((29932.33 29..."
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#plotting-geospatial-data",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#plotting-geospatial-data",
    "title": "Hands-on Exercise 1.1",
    "section": "Plotting Geospatial Data",
    "text": "Plotting Geospatial Data\nUsing plot() to visualise the geospatial features. The default plot of an sf object is a multi-plot of all attributes (columns), up to a reasonable maximum as shown below.\n(Note: plot() is mean for plotting the geospatial object for quick look. For high cartographic quality plot, other R package such as tmap should be used.)\n\nplot(mpsz)\n\nWarning: plotting the first 9 out of 15 attributes; use max.plot = 15 to plot\nall\n\n\n\n\n\nWe can customise our plot by choosing to plot only the geometry, using the code chunk below.\n\nplot(st_geometry(mpsz))\n\n\n\n\nAlternatively, we can also choose to plot the sf object by using a specific attribute as shown in the code chunk below.\n\nplot(mpsz['PLN_AREA_N'])"
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#working-with-projection",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#working-with-projection",
    "title": "Hands-on Exercise 1.1",
    "section": "Working with Projection",
    "text": "Working with Projection\nIn order to perform geoprocessing using two geospatial data, we need to ensure that both geospatial data are projected using similar coordinate reference system (crs). When we project a simple feature (sf) dataframe from one crs to another crs, this process is called projection transformation.\nCheck the coordinate reference system of a sd dataframe using st_crs(). In the below sf dataframe, although it is projected in svy21, but when we read till the end of the print, it indicates that the EPSG is 9001. This is a wrong EPSG code because the correct EPSG code for svy21 should be 3414.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nIn order to assign the correct EPSG code to, st_set_crs() of sf package is used as shown in the code chunk below. Note that this does not perform projection transformation, it only changes/corrects the assigned crs for the dataframe.\n\nmpsz3414 <- st_set_crs(mpsz, 3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\nIn geospatial analytics, it is very common for us to transform the original data from geographic coordinate system to projected coordinate system. This is because geographic coordinate system is not appropriate if the analysis need to use distance or/and area measurements.\nFor example, in the preschool sf dataframe, it is in wgs84 crs.\n\nst_crs(preschool)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n\n\nTo reproject preschool from one crs to another crs mathematically, we need to perform projection transformation using the code chunk below.\n(Note: In practice, we need to find out the appropriate project crs to use before performing projection transformation. In Singapore, we typically use we typically use SVY21 or 3414).\n(Note: We can combine this step when we load in the data as well, using piping to follow st_read with the st_transform function)\n\npreschool3414 <- st_transform(preschool, crs=3414)\nst_crs(preschool3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]"
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#importing-and-converting-aspatial-data",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#importing-and-converting-aspatial-data",
    "title": "Hands-on Exercise 1.1",
    "section": "Importing and Converting Aspatial Data",
    "text": "Importing and Converting Aspatial Data\nIn practice, it is not unusual that we will come across aspatial data. These are not geospatial data but among the data fields, there are two fields that capture the x- and y-coordinates of the data points. We will learn to import an aspatial data into R environment and save it as a tibble data frame. Then, we will convert it into a sf dataframe.\nWe will load in the listings.csv data from AirBnb. As it is in csv format, we will use read_csv() of readr package to import the file. The output R object from read_csv() is a tibble dataframe.\n\nlistings <- read_csv('data/aspatial/listings.csv')\n\nRows: 4252 Columns: 16\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr   (5): name, host_name, neighbourhood_group, neighbourhood, room_type\ndbl  (10): id, host_id, latitude, longitude, price, minimum_nights, number_o...\ndate  (1): last_review\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nUse list() from Base R (instead of glimpse()) to examine the tibble dataframe. Two useful fields we are going to use in the next phase are latitude and longitude. Note that they are in decimal degree format. As a best guess, we will assume that the data is in wgs84 Geographic Coordinate System.\n\nlist(listings)\n\n[[1]]\n# A tibble: 4,252 × 16\n       id name     host_id host_…¹ neigh…² neigh…³ latit…⁴ longi…⁵ room_…⁶ price\n    <dbl> <chr>      <dbl> <chr>   <chr>   <chr>     <dbl>   <dbl> <chr>   <dbl>\n 1  50646 Pleasan…  227796 Sujatha Centra… Bukit …    1.33    104. Privat…    80\n 2  71609 Ensuite…  367042 Belinda East R… Tampin…    1.35    104. Privat…   178\n 3  71896 B&B  Ro…  367042 Belinda East R… Tampin…    1.35    104. Privat…    81\n 4  71903 Room 2-…  367042 Belinda East R… Tampin…    1.35    104. Privat…    81\n 5 275343 Conveni… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    52\n 6 275344 15 mins… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    40\n 7 294281 5 mins … 1521514 Elizab… Centra… Newton     1.31    104. Privat…    72\n 8 301247 Nice ro… 1552002 Rahul   Centra… Geylang    1.32    104. Privat…    41\n 9 324945 20 Mins… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    49\n10 330089 Accomo@… 1439258 Joyce   Centra… Bukit …    1.29    104. Privat…    49\n# … with 4,242 more rows, 6 more variables: minimum_nights <dbl>,\n#   number_of_reviews <dbl>, last_review <date>, reviews_per_month <dbl>,\n#   calculated_host_listings_count <dbl>, availability_365 <dbl>, and\n#   abbreviated variable names ¹​host_name, ²​neighbourhood_group,\n#   ³​neighbourhood, ⁴​latitude, ⁵​longitude, ⁶​room_type\n\n\nThe code chunk below converts listing dataframe into a sf dataframe by using st_as_sf() of sf packages.\n\ncoords argument requires us to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.\ncrs argument requires us to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. We can search for other country’s epsg code by referring to epsg.io.\n\n\nlisting_sf <- st_as_sf(listings,\n                       coords = c('longitude', 'latitude'),\n                       crs=4326) %>% \n  st_transform(crs=3414)\n\nWe can examine the content of the newly created sf dataframe using glimpse(). The table below shows the content of listing_sf. Notice that a new column called geometry has been added into the dataframe. On the other hand, the longitude and latitude columns have been dropped from the data frame.\n\nglimpse(listing_sf)\n\nRows: 4,252\nColumns: 15\n$ id                             <dbl> 50646, 71609, 71896, 71903, 275343, 275…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <dbl> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <dbl> 80, 178, 81, 81, 52, 40, 72, 41, 49, 49…\n$ minimum_nights                 <dbl> 90, 90, 90, 90, 14, 14, 90, 8, 14, 14, …\n$ number_of_reviews              <dbl> 18, 20, 24, 48, 20, 13, 133, 105, 14, 1…\n$ last_review                    <date> 2014-07-08, 2019-12-28, 2014-12-10, 20…\n$ reviews_per_month              <dbl> 0.22, 0.28, 0.33, 0.67, 0.20, 0.16, 1.2…\n$ calculated_host_listings_count <dbl> 1, 4, 4, 4, 50, 50, 7, 1, 50, 50, 50, 4…\n$ availability_365               <dbl> 365, 365, 365, 365, 353, 364, 365, 90, …\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…"
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#geoprocessing-with-sf-package",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.1.html#geoprocessing-with-sf-package",
    "title": "Hands-on Exercise 1.1",
    "section": "Geoprocessing with sf package",
    "text": "Geoprocessing with sf package\nBesides providing functions to handling (i.e. importing, exporting, assigning projection, transforming projection etc) geospatial data, sf package also offers a wide range of geoprocessing (also known as GIS analysis) functions. Specifically, we will learn how to perform two commonly used geoprocessing functions, namely buffering and point in polygon count.\n\nBuffering\nThe scenario:\nThe authority is planning to upgrade the existing cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extent of the land need to be acquired and their total area.\nThe solution:\nFirstly, st_buffer() of sf package is used to compute the 5-meter buffers around cycling paths.\n\nbuffer_cycling <- st_buffer(cyclingpath,\n                            dist=5,\n                            nQuadSegs=30)\n\nThis is followed by calculating the area of the buffers as shown in the code chunk below.\n\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\nLastly, sum() of Base R will be used to derive the total land involved\n\nsum(buffer_cycling$AREA)\n\n773143.9 [m^2]\n\n\n\n\nPoint-in-polygon count\nThe scenario:\nA pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\nThe solution:\nThe code chunk below performs two operations at one go. Firstly, identify pre-schools located inside each Planning Subzone by using st_intersects(). Next, lengths() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.\n\nmpsz3414$PreSch_Count <- lengths(st_intersects(mpsz3414, preschool3414))\n\nWe can check the summary statistics of the newly derived PreSch Count field by using summary() as shown in the code chunk below.\n\nsummary(mpsz3414$PreSch_Count)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.000   4.207   6.000  37.000 \n\n\nTo list the planning subzone with the most number of pre-school, the top_n() of dplyr package is used as shown in the code chunk below.\n\ntop_n(mpsz3414, 1, PreSch_Count)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 23449.05 ymin: 46001.23 xmax: 25594.22 ymax: 47996.47\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      290          3 WOODLANDS EAST    WDSZ03      N  WOODLANDS         WD\n      REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR\n1 NORTH REGION       NR C90769E43EE6B0F2 2014-12-05 24506.64 46991.63\n  SHAPE_Leng SHAPE_Area                       geometry PreSch_Count\n1   6603.608    2553464 MULTIPOLYGON (((24786.75 46...           37\n\n\nThe solution:\nFirstly, the code chunk below uses st_area() of sf package to derive the area of each planning subzone.\n\nmpsz3414$Area <- mpsz3414 %>%\n  st_area()\n\nNext, mutate() of dplyr package is used to compute the density by using the code chunk below.\n\nmpsz3414 <- mpsz3414 %>% \n  mutate(PreSch_Density = PreSch_Count/Area * 1000000)\n\n\n\nExploratory Data Analysis (EDA)\nWe can plot a histogram to reveal the distribution of PreSch_Density.\n\nggplot(data=mpsz3414,\n       aes(x=as.numeric(PreSch_Density))) +\n  geom_histogram(bins=20,\n                 color='black',\n                 fill='salmon') +\n  labs(title='Are pre-schools evenly distributed in Singapore?',\n       subtitle='There are many planning subzones with a single pre-school.\\nOn the other hand, there are two planning subzones with at least 20 pre-schools.',\n       x='Pre-school Density (per km sq)',\n       y='Frequency')\n\n\n\n\nWe can plot a scatterplot to show the relationship between PreSch_Density and PreSch_Count.\n\nggplot(data=mpsz3414,\n       aes(x=as.numeric(PreSch_Density),\n           y=PreSch_Count)) +\n  geom_point() +\n  labs(title='How are the pre-school counts related to the pre-school density?',\n       x='Pre-school Density (per km sq)',\n       y='Pre-school count')"
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.2.html",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.2.html",
    "title": "Hands-on Exercise 1.2",
    "section": "",
    "text": "This exercise covers the following:\n\nChoropleth Mapping with R"
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.2.html#getting-started",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.2.html#getting-started",
    "title": "Hands-on Exercise 1.2",
    "section": "Getting Started",
    "text": "Getting Started\nInstall and load the necessary packages\n\npacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.2.html#reading-in-geospatial-data",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.2.html#reading-in-geospatial-data",
    "title": "Hands-on Exercise 1.2",
    "section": "Reading in Geospatial Data",
    "text": "Reading in Geospatial Data\nReading in MP14_SUBZONE_WEB_PL shapefile.\n\nmpsz <- st_read(dsn = 'data/geospatial',\n                layer = 'MP14_SUBZONE_WEB_PL')\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\Users\\fongb\\Desktop\\MITB\\ISSS624 - Applied Geospatial Analytics\\quarto\\fongbx\\ISSS624\\hands-on_exercises\\hands-on_ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nExamine content of mpsz using the code chunk below\n\nmpsz\n\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29..."
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.2.html#reading-in-attribute-data",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.2.html#reading-in-attribute-data",
    "title": "Hands-on Exercise 1.2",
    "section": "Reading in Attribute Data",
    "text": "Reading in Attribute Data\nReading in Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020 in csv format. This is an aspatial data fie. Although it does not contain any coordinates values, but it’s PA and SZ fields can be used as unique identifiers to geocode to MP14_SUBZONE_WEB_PL shapefile.\n\npopdata <- read_csv('data/aspatial/respopagesextod2011to2020.csv')\n\nRows: 984656 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): PA, SZ, AG, Sex, TOD\ndbl (2): Pop, Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.2.html#data-preparation",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.2.html#data-preparation",
    "title": "Hands-on Exercise 1.2",
    "section": "Data Preparation",
    "text": "Data Preparation\nExamine popdata\n\nhead(popdata, n=3)\n\n# A tibble: 3 × 7\n  PA         SZ                     AG     Sex   TOD                   Pop  Time\n  <chr>      <chr>                  <chr>  <chr> <chr>               <dbl> <dbl>\n1 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 1- and 2-Room …     0  2011\n2 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 3-Room Flats       10  2011\n3 Ang Mo Kio Ang Mo Kio Town Centre 0_to_4 Males HDB 4-Room Flats       30  2011\n\n\nWrangling popdata to capture the population by the different age groups\n\npivot_wider() “widens” data, increasing the number of columns and decreasing the number of rows\n\n\npopdata2020 <- popdata %>% \n  filter(Time == 2020) %>% \n  group_by(PA, SZ, AG) %>% \n  summarise(POP = sum(Pop)) %>% \n  ungroup() %>% \n  pivot_wider(names_from = AG,\n              values_from = POP)\n\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n\npopdata2020\n\n# A tibble: 332 × 21\n   PA      SZ    0_to_…¹ 10_to…² 15_to…³ 20_to…⁴ 25_to…⁵ 30_to…⁶ 35_to…⁷ 40_to…⁸\n   <chr>   <chr>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1 Ang Mo… Ang …     170     280     340     270     260     310     330     400\n 2 Ang Mo… Chen…    1060    1040    1160    1330    1720    2020    2150    2080\n 3 Ang Mo… Chon…     850    1020    1070    1310    1610    1890    1720    1810\n 4 Ang Mo… Kebu…     680     960    1010    1170    1410    1420    1440    1630\n 5 Ang Mo… Semb…     210     400     450     500     500     340     300     370\n 6 Ang Mo… Shan…     560     640     700     860     970    1030     980    1010\n 7 Ang Mo… Tago…     200     390     460     590     680     500     330     430\n 8 Ang Mo… Town…     670     930     830     890    1310    1410    1420    1640\n 9 Ang Mo… Yio …       0       0       0       0       0       0       0       0\n10 Ang Mo… Yio …     160     210     260     300     320     240     250     260\n# … with 322 more rows, 11 more variables: `45_to_49` <dbl>, `5_to_9` <dbl>,\n#   `50_to_54` <dbl>, `55_to_59` <dbl>, `60_to_64` <dbl>, `65_to_69` <dbl>,\n#   `70_to_74` <dbl>, `75_to_79` <dbl>, `80_to_84` <dbl>, `85_to_89` <dbl>,\n#   `90_and_over` <dbl>, and abbreviated variable names ¹​`0_to_4`, ²​`10_to_14`,\n#   ³​`15_to_19`, ⁴​`20_to_24`, ⁵​`25_to_29`, ⁶​`30_to_34`, ⁷​`35_to_39`,\n#   ⁸​`40_to_44`\n\n\nFurther transformation of data, creating new column based on the following:\n\nYOUNG: age group 0 to 4 until age group 20 to 24,\nECONOMY ACTIVE: age group 25-29 until age group 60-64,\nAGED: age group 65 and above,\nTOTAL: all age group, and\nDEPENDENCY: the ratio between young and aged against economy active group\n\n\npopdata2020 <- popdata2020 %>% \n  mutate(YOUNG = rowSums(.[3:6]) + rowSums(.[12])) %>% \n  mutate(ECONOMY_ACTIVE = rowSums(.[7:11]) + rowSums(.[13:15])) %>% \n  mutate(AGED = rowSums(.[16:21])) %>% \n  mutate(TOTAL = rowSums(.[3:21])) %>% \n  mutate(DEPENDENCY = (YOUNG + AGED)/ECONOMY_ACTIVE) %>% \n  select(PA, SZ, YOUNG, ECONOMY_ACTIVE, AGED, TOTAL, DEPENDENCY)\npopdata2020\n\n# A tibble: 332 × 7\n   PA         SZ                     YOUNG ECONOMY_ACTIVE  AGED TOTAL DEPENDENCY\n   <chr>      <chr>                  <dbl>          <dbl> <dbl> <dbl>      <dbl>\n 1 Ang Mo Kio Ang Mo Kio Town Centre  1290           2760   760  4810      0.743\n 2 Ang Mo Kio Cheng San               5640          16460  6050 28150      0.710\n 3 Ang Mo Kio Chong Boon              5100          15000  6470 26570      0.771\n 4 Ang Mo Kio Kebun Bahru             4620          13010  5120 22750      0.749\n 5 Ang Mo Kio Sembawang Hills         1880           3630  1310  6820      0.879\n 6 Ang Mo Kio Shangri-La              3330           9050  3610 15990      0.767\n 7 Ang Mo Kio Tagore                  1940           4480  1530  7950      0.775\n 8 Ang Mo Kio Townsville              4190          11950  5100 21240      0.777\n 9 Ang Mo Kio Yio Chu Kang               0              0     0     0    NaN    \n10 Ang Mo Kio Yio Chu Kang East       1110           2410   750  4270      0.772\n# … with 322 more rows\n\n\nBefore we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other hand the SUBZONE_N and PLN_AREA_N are in uppercase.\n\nmutate_at makes it easier to mutate multiple columns. .funs behaves like a lambda\n\n\npopdata2020 <- popdata2020 %>% \n  mutate_at(.vars = vars(PA, SZ),\n            .funs = funs(toupper)) %>% \n  filter(ECONOMY_ACTIVE > 0)\n\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nℹ Please use a list of either functions or lambdas:\n\n# Simple named list: list(mean = mean, median = median)\n\n# Auto named with `tibble::lst()`: tibble::lst(mean, median)\n\n# Using lambdas list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\n\npopdata2020\n\n# A tibble: 234 × 7\n   PA         SZ                     YOUNG ECONOMY_ACTIVE  AGED TOTAL DEPENDENCY\n   <chr>      <chr>                  <dbl>          <dbl> <dbl> <dbl>      <dbl>\n 1 ANG MO KIO ANG MO KIO TOWN CENTRE  1290           2760   760  4810      0.743\n 2 ANG MO KIO CHENG SAN               5640          16460  6050 28150      0.710\n 3 ANG MO KIO CHONG BOON              5100          15000  6470 26570      0.771\n 4 ANG MO KIO KEBUN BAHRU             4620          13010  5120 22750      0.749\n 5 ANG MO KIO SEMBAWANG HILLS         1880           3630  1310  6820      0.879\n 6 ANG MO KIO SHANGRI-LA              3330           9050  3610 15990      0.767\n 7 ANG MO KIO TAGORE                  1940           4480  1530  7950      0.775\n 8 ANG MO KIO TOWNSVILLE              4190          11950  5100 21240      0.777\n 9 ANG MO KIO YIO CHU KANG EAST       1110           2410   750  4270      0.772\n10 ANG MO KIO YIO CHU KANG WEST       5690          13750  4680 24120      0.754\n# … with 224 more rows\n\n\nNext, left_join() of dplyr is used to join the geographical data and attribute table using planning subzone name e.g. SUBZONE_N and SZ as the common identifier. The mpsz dataset is used as the left data table to ensure that the output will be a sf dataframe.\n\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c('SUBZONE_N' = 'SZ'))\nmpsz_pop2020\n\nSimple feature collection with 323 features and 21 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area              PA YOUNG ECONOMY_ACTIVE AGED\n1  29220.19   5267.381  1630379.3            <NA>    NA             NA   NA\n2  29782.05   3506.107   559816.2          OUTRAM   930           3130 2120\n3  29974.66   1740.926   160807.5 SINGAPORE RIVER     0             40   10\n4  29933.77   3313.625   595428.9     BUKIT MERAH  2600           7450 3320\n5  30005.70   2825.594   387429.4     BUKIT MERAH  2760           6160 1740\n6  29991.38   4428.913  1030378.8     BUKIT MERAH  2800           7340 3420\n7  30230.86   3275.312   551732.0     BUKIT MERAH  2750           8080 3610\n8  30222.86   2208.619   290184.7 SINGAPORE RIVER     0             50   10\n9  29893.78   6571.323  1084792.3      QUEENSTOWN  1120           2770  610\n10 30104.18   3454.239   631644.3      QUEENSTOWN    30            160   60\n   TOTAL DEPENDENCY                       geometry\n1     NA         NA MULTIPOLYGON (((31495.56 30...\n2   6180  0.9744409 MULTIPOLYGON (((29092.28 30...\n3     50  0.2500000 MULTIPOLYGON (((29932.33 29...\n4  13370  0.7946309 MULTIPOLYGON (((27131.28 30...\n5  10660  0.7305195 MULTIPOLYGON (((26451.03 30...\n6  13560  0.8474114 MULTIPOLYGON (((25899.7 297...\n7  14440  0.7871287 MULTIPOLYGON (((27746.95 30...\n8     60  0.2000000 MULTIPOLYGON (((29351.26 29...\n9   4500  0.6245487 MULTIPOLYGON (((20996.49 30...\n10   250  0.5625000 MULTIPOLYGON (((24472.11 29...\n\n\nWrite to an rds file\n\nwrite_rds(mpsz_pop2020, 'data/rds/mpszpop2020_new.rds')"
  },
  {
    "objectID": "hands-on_exercises/hands-on_ex1/hands-on_ex1.2.html#choropleth-mapping-geospatial-data-using-tmap",
    "href": "hands-on_exercises/hands-on_ex1/hands-on_ex1.2.html#choropleth-mapping-geospatial-data-using-tmap",
    "title": "Hands-on Exercise 1.2",
    "section": "Choropleth Mapping Geospatial Data using tmap",
    "text": "Choropleth Mapping Geospatial Data using tmap\nTwo approaches can be used to prepare thematic map using tmap, they are:\n\nPlotting a thematic map quickly by using qtm().\nPlotting highly customisable thematic map by using tmap elements.\n\n\nPlotting a choropleth map quickly by using qtm()\nThe easiest and quickest to draw a choropleth map using tmap is using qtm(). It is concise and provides a good default visualisation in many cases. The code chunk below will draw a cartographic standard choropleth map.\n\ntmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.\nfill argument is used to map the attribute (i.e. DEPENDENCY)\n\n\ntmap_mode('plot')\n\ntmap mode set to plotting\n\nqtm(mpsz_pop2020,\n    fill = 'DEPENDENCY')\n\n\n\n\n\n\nCreating a choropleth map by using tmap’s elements\nDespite its usefulness of drawing a choropleth map quickly and easily, the disadvantge of qtm() is that it makes aesthetics of individual layers harder to control. To draw a high quality cartographic choropleth map as shown in the figure below, tmap’s drawing elements should be used.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = 'Blues',\n          title = 'Dependency ratio') +\n  tm_layout(main.title = 'Distribution of Dependency Ratio by planning subzone',\n            main.title.position = 'center',\n            main.title.size = 1,\n            legend.height = 0.25,\n            legend.width = 0.2,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type = '8star', size = 0.6) +\n  tm_scale_bar() +\n  tm_grid(alpha = 0.2) +\n  tm_credits('Source: Planning Sub-zone boundary from Urban Redevelopment Authority (URA) and Population data from Department of Statistics DOS',\n             position = c('left', 'bottom'))\n\n\n\n\nThe following are step-by-step breakdown of tmap functions:\n\nDrawing a base map\nThe basic building block of tmap is tm_shape() followed by one or more layer elemments such as tm_fill() and tm_polygons(). In the code chunk below, tm_shape() is used to define the input data (i.e mpsz_pop2020) and tm_polygons() is used to draw the planning subzone polygons.\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n\n\n\n\n\n\nDrawing a choropleth map using tm_polygons()\nTo draw a choropleth map showing the geographical distribution of a selected variable by planning subzone, we just need to assign the target variable such as Dependency to tm_polygons().\n\ntm_shape(mpsz_pop2020) + \n  tm_polygons('DEPENDENCY')\n\n\n\n\n\n\nDrawing a choropleth map using tm_polygons()\nActually, tm_polygons() is a wrapper of tm_fill() and tm_border(). tm_fill() shades the polygons by using the default colour scheme and tm_borders() adds the borders of the shapefile onto the choropleth map. The code chunk below draws a choropleth map by using tm_fill() alone.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY')\n\n\n\n\nTo add the boundary of the planning subzones, tm_borders will be used.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY') +\n  tm_borders(lwd = 0.1, alpha = 1)\n\n\n\n\n\n\nData classification methods of tmap\nMost choropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes. tmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks. To define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.\nThe code chunk below shows a quantile data classification that used 5 classes.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          n = 5,\n          style = 'quantile') +\n  tm_borders(alpha = 0.5)\n\n\n\n\nThe below code chunk uses equal data classification method.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          n = 7,\n          style = 'equal') +\n  tm_borders(alpha = 0.5)\n\n\n\n\nThe below code chunk uses kmeans data classification method.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          n = 5,\n          style = 'kmeans') +\n  tm_borders(alpha=0.5)\n\n\n\n\n\n\nPlotting choropleth map with custom break\nFor all built-in classfication styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the tm_fill(). It is important to note that, in tmap the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order).\nBefore we get started, it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics of DEPENDENCY field.\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6519  0.7025  0.7742  0.7645 19.0000      92 \n\n\nUsing the results above, we set break points at 0.60, 0.70, 0.80, and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 19.00. Our breaks vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 19.00).\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          breaks = c(0,0.60,0.70,0.80,0.90,19.00)) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\nColour Scheme\ntmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package. To change the colour, we assign the preferred colour to palette argument of tm_fill() as shown in the code chunk below.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          n = 6,\n          style = 'quantile',\n          palette = 'Blues') +\n  tm_borders(alpha = 0.5)\n\n\n\n\nTo revers the colour shading, add a ‘-’ prefix.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = '-Blues') +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\nMap Layouts\nMap layout refers to the combination of all map elements into a cohensive map. Map elements include among others the objects to be mapped, the title, the scale bar, the compass, margins and aspects ratios. Colour settings and data classification methods covered in the previous section relate to the palette and break-points are used to affect how the map looks.\nMap Legend - In tmap, several legend options are provided to change the placement, format and appearance of the legend.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style = 'jenks',\n          palette = 'Blues',\n          legend.hist = TRUE,\n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = 'Distribution of Dependency Ratio by planning subzone',\n            main.title.position = 'center',\n            main.title.size = 1,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c('right','bottom'),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\nMap Style - tmap allows a wide variety of layout settings to be changed. They can be called by using tmap_style().\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = 'Greens') +\n  tm_borders(alpha = 0.5) +\n  tmap_style('classic')\n\ntmap style set to \"classic\"\n\n\nother available styles are: \"white\", \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"watercolor\" \n\n\n\n\n\nCartographic Furniture - Beside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines. In the code chunk below, tm_compass(), tm_scale_bar() and tm_grid() are used to add compass, scale bar and grid lines onto the choropleth map.\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = 'Blues',\n          title = 'No. of persons') +\n  tm_layout(main.title = 'Distribution of Dependency Ratio by planning subzone',\n            main.title.position = 'center',\n            main.title.size = 1,\n            legend.height = 0.25,\n            legend.width = 0.2,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type = '8star', size = 0.6) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits('Source: Planning Sub-zone boundary from Urban Redevelopment Authority (URA) and Population data from Department of Statistics DOS',\n             position = c('left', 'bottom')) +\n  tmap_style('cobalt')\n\ntmap style set to \"cobalt\"\n\n\nother available styles are: \"white\", \"gray\", \"natural\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\n\n\nDrawing small multiple choropleth maps\nIn tmap, small multiple maps can be plotted in three ways:\n\nby assigning multiple values to at least one of the asthetic arguments,\nby defining a group-by variable in tm_facets(), and\nby creating multiple stand-alone maps with tmap_arrange().\n\nAssigning multiple values to at least one of the aesthetics arguments\nIn this example, small multiple choropleth maps are created by defining ncols in tm_fill().\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(c('YOUNG', 'AGED'),\n          style = 'equal',\n          palette = 'Blues') +\n  tm_layout(legend.position = c('right', 'bottom')) +\n  tm_borders(alpha = 0.5) +\n  tmap_style('white')\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\nIn this example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments.\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n\n\n\n\nDefining a group_by variable in tm_facets()\nIn this example, multiple small choropleth maps are created by using tm_facets().\n\ntm_shape(mpsz_pop2020) +\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = 'Blues',\n          thres.poly = 0) +\n  tm_facets(by = 'REGION_N',\n            free.coords = TRUE,\n            drop.shapes = TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c('center', 'center'),\n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\nWarning: The argument drop.shapes has been renamed to drop.units, and is\ntherefore deprecated\n\n\n\n\n\nCreating multiple stand-alone maps with tmap_arrange()\nIn this example, multiple small choropleth maps are created by creating multiple stand-alone maps with tmap_arrange().\n\nyoungmap <- tm_shape(mpsz_pop2020) +\n  tm_polygons('YOUNG',\n              style = 'quantile',\n              palette = 'Blues')\n\nagedmap <- tm_shape(mpsz_pop2020) +\n  tm_polygons('AGED',\n              style = 'quantile',\n              palette = 'Blues')\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n\n\n\n\n\n\nMapping Spatial Object Meeting a Selection Criteria\nInstead of creating small multiple choropleth map, you can also use selection function to map spatial objects meeting the selection criterion.\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N=='CENTRAL REGION', ]) +\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nWarning in pre_process_gt(x, interactive = interactive, orig_crs =\ngm$shape.orig_crs): legend.width controls the width of the legend within a map.\nPlease use legend.outside.size to control the width of the outside legend"
  },
  {
    "objectID": "in-class_exercises/in-class_ex1/in-class_ex1.html#importing-csv-data",
    "href": "in-class_exercises/in-class_ex1/in-class_ex1.html#importing-csv-data",
    "title": "In-class Exercise 1",
    "section": "Importing csv Data",
    "text": "Importing csv Data\nThis code chunk will import Hunan_2012.csv file into R\n\n# hunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')"
  },
  {
    "objectID": "in-class_exercises/in-class_ex1/in-class_ex1.html#importing-data",
    "href": "in-class_exercises/in-class_ex1/in-class_ex1.html#importing-data",
    "title": "In-class Exercise 1",
    "section": "Importing Data",
    "text": "Importing Data\n\nImporting Geospatial Data\nThis code chunk will import Hunan shapefile into R. The imported shapefile will be simple features object of sf.\n\nhunan <- st_read(dsn = 'data/geospatial',\n                layer = 'Hunan')\n\nReading layer `Hunan' from data source \n  `C:\\Users\\fongb\\Desktop\\MITB\\ISSS624 - Applied Geospatial Analytics\\quarto\\fongbx\\ISSS624\\in-class_exercises\\in-class_ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\nExamine the hunan sf dataframe.\n\nhead(hunan, n=3)\n\nSimple feature collection with 3 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 111.7027 ymin: 28.61762 xmax: 112.3013 ymax: 29.77344\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3 Shape_Leng Shape_Area  County\n1 Changde 21098 Anxiang      County   1.869074 0.10056190 Anxiang\n2 Changde 21100 Hanshou      County   2.360691 0.19978745 Hanshou\n3 Changde 21101  Jinshi County City   1.425620 0.05302413  Jinshi\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n\n\n\n\nImporting CSV Data\nNext, we will import Hunan_2012.csv into R by using read_csv() of readr package. The output is R dataframe class.\n\nhunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')\n\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nExamine the hunan2012 dataframe.\n\nhead(hunan2012)\n\n# A tibble: 6 × 29\n  County   City  avg_w…¹ depos…²   FAI Gov_Rev Gov_Exp    GDP GDPPC    GIO  Loan\n  <chr>    <chr>   <dbl>   <dbl> <dbl>   <dbl>   <dbl>  <dbl> <dbl>  <dbl> <dbl>\n1 Anhua    Yiya…   30544  10967  6832.    457.   2703  13225  14567  9277. 3955.\n2 Anren    Chen…   28058   4599. 6386.    221.   1455.  4941. 12761  4189. 2555.\n3 Anxiang  Chan…   31935   5517. 3541     244.   1780. 12482  23667  5109. 2807.\n4 Baojing  Huna…   30843   2250  1005.    193.   1379.  4088. 14563  3624. 1254.\n5 Chaling  Zhuz…   31251   8241. 6508.    620.   1947  11585  20078  9158. 4287.\n6 Changni… Heng…   28518  10860  7920     770.   2632. 19886  24418 37392  4243.\n# … with 18 more variables: NIPCR <dbl>, Bed <dbl>, Emp <dbl>, EmpR <dbl>,\n#   EmpRT <dbl>, Pri_Stu <dbl>, Sec_Stu <dbl>, Household <dbl>,\n#   Household_R <dbl>, NOIP <dbl>, Pop_R <dbl>, RSCG <dbl>, Pop_T <dbl>,\n#   Agri <dbl>, Service <dbl>, Disp_Inc <dbl>, RORP <dbl>, ROREmp <dbl>, and\n#   abbreviated variable names ¹​avg_wage, ²​deposite\n\n\n\n\nPerforming Relational Join\nThe code chunk below will be used to update the attribute table of hunan sf dataframe with the attribute fields of hunan2012 dataframe. This is performed using the left_join() of dplyr package.\n\nhunan <- left_join(hunan, hunan2012)\n\nJoining, by = \"County\"\n\nhead(hunan)\n\nSimple feature collection with 6 features and 35 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3 Shape_Leng Shape_Area  County    City\n1 Changde 21098 Anxiang      County   1.869074 0.10056190 Anxiang Changde\n2 Changde 21100 Hanshou      County   2.360691 0.19978745 Hanshou Changde\n3 Changde 21101  Jinshi County City   1.425620 0.05302413  Jinshi Changde\n4 Changde 21102      Li      County   3.474325 0.18908121      Li Changde\n5 Changde 21103   Linli      County   2.289506 0.11450357   Linli Changde\n6 Changde 21104  Shimen      County   4.171918 0.37194707  Shimen Changde\n  avg_wage deposite     FAI Gov_Rev Gov_Exp     GDP GDPPC     GIO   Loan  NIPCR\n1    31935   5517.2  3541.0  243.64  1779.5 12482.0 23667  5108.9 2806.9 7693.7\n2    32265   7979.0  8665.0  386.13  2062.4 15788.0 20981 13491.0 4550.0 8269.9\n3    28692   4581.7  4777.0  373.31  1148.4  8706.9 34592 10935.0 2242.0 8169.9\n4    32541  13487.0 16066.0  709.61  2459.5 20322.0 24473 18402.0 6748.0 8377.0\n5    32667    564.1  7781.2  336.86  1538.7 10355.0 25554  8214.0  358.0 8143.1\n6    33261   8334.4 10531.0  548.33  2178.8 16293.0 27137 17795.0 6026.5 6156.0\n   Bed    Emp  EmpR EmpRT Pri_Stu Sec_Stu Household Household_R NOIP Pop_R\n1 1931 336.39 270.5 205.9  19.584  17.819     148.1       135.4   53 346.0\n2 2560 456.78 388.8 246.7  42.097  33.029     240.2       208.7   95 553.2\n3  848 122.78  82.1  61.7   8.723   7.592      81.9        43.7   77  92.4\n4 2038 513.44 426.8 227.1  38.975  33.938     268.5       256.0   96 539.7\n5 1440 307.36 272.2 100.8  23.286  18.943     129.1       157.2   99 246.6\n6 2502 392.05 329.6 193.8  29.245  26.104     190.6       184.7  122 399.2\n    RSCG Pop_T    Agri Service Disp_Inc      RORP    ROREmp\n1 3957.9 528.3 4524.41   14100    16610 0.6549309 0.8041262\n2 4460.5 804.6 6545.35   17727    18925 0.6875466 0.8511756\n3 3683.0 251.8 2562.46    7525    19498 0.3669579 0.6686757\n4 7110.2 832.5 7562.34   53160    18985 0.6482883 0.8312558\n5 3604.9 409.3 3583.91    7031    18604 0.6024921 0.8856065\n6 6490.7 600.5 5266.51    6981    19275 0.6647794 0.8407091\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675..."
  },
  {
    "objectID": "in-class_exercises/in-class_ex1/in-class_ex1.html#visualising-regional-development-indicator",
    "href": "in-class_exercises/in-class_ex1/in-class_ex1.html#visualising-regional-development-indicator",
    "title": "In-class Exercise 1",
    "section": "Visualising Regional Development Indicator",
    "text": "Visualising Regional Development Indicator\nNow, we will prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmap package.\n\nbasemap <- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text('NAME_3', size=0.4)\n\ngdppc <- qtm(hunan, fill='GDPPC')\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "in-class_exercises/in-class_ex1/in-class_ex1.html#computing-contiguity-spatial-weights",
    "href": "in-class_exercises/in-class_ex1/in-class_ex1.html#computing-contiguity-spatial-weights",
    "title": "In-class Exercise 1",
    "section": "Computing Contiguity Spatial Weights",
    "text": "Computing Contiguity Spatial Weights\nIn this section, we will learn how to use poly2nb() of spdep package to compute contiguity weight matrices for the study area. This function builds a neighbours list based on regions with contiguous boundaries. This function has a \"queen\" argument that takes TRUE or FALSE as options. If we do not specify this argument the default is set to TRUE, that is, if we don't specify queen = FALSE this function will return a list of first order neighbours using the Queen criteria.\n\nComputing QUEEN contiguity based neighbours\nThe code chunk below is used to compute Queen contiguity weight matrix. The summary report shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one neighbour.\n\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\nFor each polygon in our polygon object, wm_q lists all neighbouring polygons. For example, to see the neighbours for the first polygon, we use the below code. It shows that Polygon 1 has 5 neighbours. The numbers represent the polygon IDs as stored in Hunan sf dataframe.\n\nwm_q[[1]]\n\n[1]  2  3  4 57 85\n\n\nWe can retreive the county name of Polygon ID=1 using the code chunk below.\n\nhunan$County[1]\n\n[1] \"Anxiang\"\n\n\nTo reveal the county names of the five neighbouring polygons, we use the code chunk below.\n\nhunan$County[c(2,3,4,57,85)]\n\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n\n\nWe can retreive the GDPPC of these five countries by using the code chunk below. The printed output shows that the GDPPC of the five nearest neighbours of Anxiang based on Queen’s method are 20981, 34592, 24473, 21311 and 22879 respectively.\n\nnb1 <- wm_q[[1]]\nnb1 <- hunan$GDPPC[nb1]\nnb1\n\n[1] 20981 34592 24473 21311 22879\n\n\nWe can display the complete weight matrix by using str().\n\nstr(wm_q)\n\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE\n\n\n\n\nComputing ROOK contiguity based neighbours\nThe code chunk below is used to compute ROOK contiguity weight matrix. The summary report shows that there are 88 area units in Hunan. The most connected area unit has 10 neighbours. There are two area units with only one neighbour.\n\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n\n\n\n\nVisualising Contiguity Weights\nA connectivity graph takes a point and displays a line to each neighboring point. We are working with polygons at the moment, so we will need to get points in order to make our connectivity graphs. The most typically method for this will be polygon centroids. We will calculate these in the sf package before moving onto the graphs.\nGetting Latitude and Longitude of Polygon Centroids\nWe will need points to associate with each polygon before we can make our connectivity graph. It will be a little more complicated than just running st_centroid on the sf object. We need the coordinates in a separate dataframe for this to work. To do this we will use a mapping function. The mapping function applies a given function to each element of a vector and returns a vector of the same length. Our input vector will be the geometry column of hunan. Our function will be st_centroid. We will be using map_dbl variation of map from the purrr package. For more documentation, check out map documentation\nTo get our longitude values we map the st_centroid function over the geometry column of hunan and access the longitude value of the centroid through double bracket notation [[]] and 1. This allows us to get only the longitude, which is the first value in each centroid.\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\nWe do the same for latitude of the centroid with one key difference, We access the second value of each centroid with [[2]].\n\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nNow that we have longitude and latitude, we use cbind to put them into the same object.\n\ncoords <- cbind(longitude, latitude)\nhead(coords)\n\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n\n\nPlotting Queen Contiguity Based Neighbours Map\nThe arguments pch refers to the plotting symbol, cex for the symbol size and add=TRUE means to add to current plot.\n\nplot(hunan$geometry, border='lightgrey')\nplot(wm_q, coords, pch=19, cex=0.6, add=TRUE, col='red')\n\n\n\n\nPlotting Rook Contiguity Based Neighbours Map\n\nplot(hunan$geometry, border='lightgrey')\nplot(wm_r, coords, pch=19, cex=0.6, add=TRUE, col='red')\n\n\n\n\nPlotting both Queen and Rook Contiguity Based Neighbours Maps\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border='lightgrey')\nplot(wm_q, coords, pch=19, cex=0.6, add=TRUE, col='red', main='Queen Contiguity')\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch=19, cex=0.6, add=TRUE, col='red', main='Rook Contiguity')"
  }
]